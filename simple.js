const lt = x => y => y < x;
const lte = x => y => y <= x;
const gt = x => y => y > x;
const gte = x => y => y >= x;
const equals = x => y => y === x;
const where = obj => item => Object.keys(obj).every(key => obj[key](item[key]));
const prop = key => obj => obj[key];
const propEq = key => value => obj => obj[key] === value;
const mergeRight = (obj1, obj2) => ({ ...obj1, ...obj2 });
const pathOr = (defaultValue, path) => obj => reduce((acc, key) => acc && acc[key], obj)(path) || defaultValue;
const len = prop('length');
const filter = (fn) => ([x, ...xs]) => isEmpty(xs) ? fn(x) ? [x] : [] : fn(x) ? [x, ...filter(fn)(xs)] : filter(fn)(xs);
const map = f => ([x, ...xs]) => isEmpty(xs) ? [f(x)] : [f(x), ...map(f)(xs)];
const pluck = (key) => map(prop(key));
const every = (fn) => ([x, ...xs]) => isEmpty(xs) ? fn(x) : fn(x) && every(fn)(xs);
const any = (fn) => ([x, ...xs]) => isEmpty(xs) ? fn(x) : fn(x) || any(fn)(xs);
const reduce = (fn, acc) => ([x, ...xs]) => isEmpty(xs) ? fn(acc, x) : reduce(fn, fn(acc, x))(xs);
const reduceRight = (fn, acc) => ([x, ...xs]) => isEmpty(xs) ? fn(x, acc) : reduceRight(fn, fn(x, acc))(xs);
const pick = reduce((acc, key) => ({ ...acc, [key]: obj[key] }), {});
const append = x => xs => [...xs, x];
const prepend = x => xs => [x, ...xs];
const head = ([x]) => x;
const tail = ([, ...xs]) => xs;
const last = xs => xs[len(xs) - 1];
const sort = f => xs => xs.sort(f);
const ifElse = (pred, f1, f2) => (...args) => pred(...args) ? f1(...args) : f2(...args);
const both = (f, g) => x => f(x) && g(x);
const either = (f, g) => x => f(x) || g(x);
