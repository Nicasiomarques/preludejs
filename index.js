export const lt = x => y => y < x;
export const lte = x => y => y <= x;
export const gt = x => y => y > x;
export const gte = x => y => y >= x;
export const equals = x => y => y === x;
export const where = obj => item => Object.keys(obj).every(key => obj[key](item[key]));
export const prop = key => obj => obj[key];
export const propEq = key => value => obj => obj[key] === value;
export const mergeRight = (obj1, obj2) => ({ ...obj1, ...obj2 });
export const pathOr = (defaultValue, path) => obj => reduce((acc, key) => acc && acc[key], obj)(path) || defaultValue;
export const len = prop('length');
export const filter = (fn) => ([x, ...xs]) => isEmpty(xs) ? fn(x) ? [x] : [] : fn(x) ? [x, ...filter(fn)(xs)] : filter(fn)(xs);
export const map = f => ([x, ...xs]) => isEmpty(xs) ? [f(x)] : [f(x), ...map(f)(xs)];
export const pluck = (key) => map(prop(key));
export const every = (fn) => ([x, ...xs]) => isEmpty(xs) ? fn(x) : fn(x) && every(fn)(xs);
export const any = (fn) => ([x, ...xs]) => isEmpty(xs) ? fn(x) : fn(x) || any(fn)(xs);
export const reduce = (fn, acc) => ([x, ...xs]) => isEmpty(xs) ? fn(acc, x) : reduce(fn, fn(acc, x))(xs);
export const reduceRight = (fn, acc) => ([x, ...xs]) => isEmpty(xs) ? fn(x, acc) : reduceRight(fn, fn(x, acc))(xs);
export const pick = reduce((acc, key) => ({ ...acc, [key]: obj[key] }), {});
export const append = x => xs => [...xs, x];
export const prepend = x => xs => [x, ...xs];
export const head = ([x]) => x;
export const tail = ([, ...xs]) => xs;
export const last = xs => xs[len(xs) - 1];
export const sort = f => xs => xs.sort(f);
export const ifElse = (pred, f1, f2) => (...args) => pred(...args) ? f1(...args) : f2(...args);
export const both = (f, g) => x => f(x) && g(x);
export const either = (f, g) => x => f(x) || g(x);
export const isEmpty = ([x]) => !x;
export const oneOf = ([x, ...xs]) => isEmpty(xs) ? equals(x) : either(equals(x), oneOf(xs));
export const isNil = oneOf([null, undefined]);
export const when = (pred, fn) => (...args) => pred(...args) ? fn(...args) : args;
export const cond = ([[pred, fn], ...xs]) => obj => pred(obj) ? fn(obj) : cond(xs)(obj);
export const pipe = (...fns) => x => reduce((acc, fn) => fn(acc), x)(fns);
export const compose = (...fns) => x => reduceRight((acc, fn) => fn(acc), x)(fns);
export const partialize = (fn, ...args) => fn.bind(null, ...args);
export const always = x => () => x;
export const ascend = f => (a, b) => f(a) > f(b) ? 1 : -1;
export const descend = f => (a, b) => f(a) > f(b) ? -1 : 1;
export const sortBy = f => sort(ascend(f))
export const T = always(true);
export const F = always(false);
export const type = x => Object.prototype.toString.call(x).slice(8, -1)
export const curry = (fn, ...args) => {
  const arity = fn.length;
  return (...rest) => {
    const allArgs = [...args, ...rest];
    return allArgs.length >= arity ? fn(...allArgs) : curry(fn, ...allArgs);
  };
};
